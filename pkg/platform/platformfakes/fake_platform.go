// Code generated by counterfeiter. DO NOT EDIT.
package platformfakes

import (
	"joblet/pkg/platform"
	"os"
	"sync"
	"syscall"
)

type FakePlatform struct {
	CreateCommandStub        func(string, ...string) *platform.ExecCommand
	createCommandMutex       sync.RWMutex
	createCommandArgsForCall []struct {
		arg1 string
		arg2 []string
	}
	createCommandReturns struct {
		result1 *platform.ExecCommand
	}
	createCommandReturnsOnCall map[int]struct {
		result1 *platform.ExecCommand
	}
	CreateProcessGroupStub        func() *syscall.SysProcAttr
	createProcessGroupMutex       sync.RWMutex
	createProcessGroupArgsForCall []struct {
	}
	createProcessGroupReturns struct {
		result1 *syscall.SysProcAttr
	}
	createProcessGroupReturnsOnCall map[int]struct {
		result1 *syscall.SysProcAttr
	}
	EnvironStub        func() []string
	environMutex       sync.RWMutex
	environArgsForCall []struct {
	}
	environReturns struct {
		result1 []string
	}
	environReturnsOnCall map[int]struct {
		result1 []string
	}
	ExecStub        func(string, []string, []string) error
	execMutex       sync.RWMutex
	execArgsForCall []struct {
		arg1 string
		arg2 []string
		arg3 []string
	}
	execReturns struct {
		result1 error
	}
	execReturnsOnCall map[int]struct {
		result1 error
	}
	ExecutableStub        func() (string, error)
	executableMutex       sync.RWMutex
	executableArgsForCall []struct {
	}
	executableReturns struct {
		result1 string
		result2 error
	}
	executableReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ExitStub        func(int)
	exitMutex       sync.RWMutex
	exitArgsForCall []struct {
		arg1 int
	}
	GetenvStub        func(string) string
	getenvMutex       sync.RWMutex
	getenvArgsForCall []struct {
		arg1 string
	}
	getenvReturns struct {
		result1 string
	}
	getenvReturnsOnCall map[int]struct {
		result1 string
	}
	GetpidStub        func() int
	getpidMutex       sync.RWMutex
	getpidArgsForCall []struct {
	}
	getpidReturns struct {
		result1 int
	}
	getpidReturnsOnCall map[int]struct {
		result1 int
	}
	IsExistStub        func(error) bool
	isExistMutex       sync.RWMutex
	isExistArgsForCall []struct {
		arg1 error
	}
	isExistReturns struct {
		result1 bool
	}
	isExistReturnsOnCall map[int]struct {
		result1 bool
	}
	IsNotExistStub        func(error) bool
	isNotExistMutex       sync.RWMutex
	isNotExistArgsForCall []struct {
		arg1 error
	}
	isNotExistReturns struct {
		result1 bool
	}
	isNotExistReturnsOnCall map[int]struct {
		result1 bool
	}
	KillStub        func(int, syscall.Signal) error
	killMutex       sync.RWMutex
	killArgsForCall []struct {
		arg1 int
		arg2 syscall.Signal
	}
	killReturns struct {
		result1 error
	}
	killReturnsOnCall map[int]struct {
		result1 error
	}
	LookPathStub        func(string) (string, error)
	lookPathMutex       sync.RWMutex
	lookPathArgsForCall []struct {
		arg1 string
	}
	lookPathReturns struct {
		result1 string
		result2 error
	}
	lookPathReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	MkdirAllStub        func(string, os.FileMode) error
	mkdirAllMutex       sync.RWMutex
	mkdirAllArgsForCall []struct {
		arg1 string
		arg2 os.FileMode
	}
	mkdirAllReturns struct {
		result1 error
	}
	mkdirAllReturnsOnCall map[int]struct {
		result1 error
	}
	MountStub        func(string, string, string, uintptr, string) error
	mountMutex       sync.RWMutex
	mountArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 uintptr
		arg5 string
	}
	mountReturns struct {
		result1 error
	}
	mountReturnsOnCall map[int]struct {
		result1 error
	}
	OpenFileStub        func(string, int, os.FileMode) (*os.File, error)
	openFileMutex       sync.RWMutex
	openFileArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 os.FileMode
	}
	openFileReturns struct {
		result1 *os.File
		result2 error
	}
	openFileReturnsOnCall map[int]struct {
		result1 *os.File
		result2 error
	}
	ReadDirStub        func(string) ([]os.DirEntry, error)
	readDirMutex       sync.RWMutex
	readDirArgsForCall []struct {
		arg1 string
	}
	readDirReturns struct {
		result1 []os.DirEntry
		result2 error
	}
	readDirReturnsOnCall map[int]struct {
		result1 []os.DirEntry
		result2 error
	}
	ReadFileStub        func(string) ([]byte, error)
	readFileMutex       sync.RWMutex
	readFileArgsForCall []struct {
		arg1 string
	}
	readFileReturns struct {
		result1 []byte
		result2 error
	}
	readFileReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	RemoveStub        func(string) error
	removeMutex       sync.RWMutex
	removeArgsForCall []struct {
		arg1 string
	}
	removeReturns struct {
		result1 error
	}
	removeReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveAllStub        func(string) error
	removeAllMutex       sync.RWMutex
	removeAllArgsForCall []struct {
		arg1 string
	}
	removeAllReturns struct {
		result1 error
	}
	removeAllReturnsOnCall map[int]struct {
		result1 error
	}
	StatStub        func(string) (os.FileInfo, error)
	statMutex       sync.RWMutex
	statArgsForCall []struct {
		arg1 string
	}
	statReturns struct {
		result1 os.FileInfo
		result2 error
	}
	statReturnsOnCall map[int]struct {
		result1 os.FileInfo
		result2 error
	}
	SymlinkStub        func(string, string) error
	symlinkMutex       sync.RWMutex
	symlinkArgsForCall []struct {
		arg1 string
		arg2 string
	}
	symlinkReturns struct {
		result1 error
	}
	symlinkReturnsOnCall map[int]struct {
		result1 error
	}
	UnmountStub        func(string, int) error
	unmountMutex       sync.RWMutex
	unmountArgsForCall []struct {
		arg1 string
		arg2 int
	}
	unmountReturns struct {
		result1 error
	}
	unmountReturnsOnCall map[int]struct {
		result1 error
	}
	WriteFileStub        func(string, []byte, os.FileMode) error
	writeFileMutex       sync.RWMutex
	writeFileArgsForCall []struct {
		arg1 string
		arg2 []byte
		arg3 os.FileMode
	}
	writeFileReturns struct {
		result1 error
	}
	writeFileReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePlatform) CreateCommand(arg1 string, arg2 ...string) *platform.ExecCommand {
	fake.createCommandMutex.Lock()
	ret, specificReturn := fake.createCommandReturnsOnCall[len(fake.createCommandArgsForCall)]
	fake.createCommandArgsForCall = append(fake.createCommandArgsForCall, struct {
		arg1 string
		arg2 []string
	}{arg1, arg2})
	stub := fake.CreateCommandStub
	fakeReturns := fake.createCommandReturns
	fake.recordInvocation("CreateCommand", []interface{}{arg1, arg2})
	fake.createCommandMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) CreateCommandCallCount() int {
	fake.createCommandMutex.RLock()
	defer fake.createCommandMutex.RUnlock()
	return len(fake.createCommandArgsForCall)
}

func (fake *FakePlatform) CreateCommandCalls(stub func(string, ...string) *platform.ExecCommand) {
	fake.createCommandMutex.Lock()
	defer fake.createCommandMutex.Unlock()
	fake.CreateCommandStub = stub
}

func (fake *FakePlatform) CreateCommandArgsForCall(i int) (string, []string) {
	fake.createCommandMutex.RLock()
	defer fake.createCommandMutex.RUnlock()
	argsForCall := fake.createCommandArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePlatform) CreateCommandReturns(result1 *platform.ExecCommand) {
	fake.createCommandMutex.Lock()
	defer fake.createCommandMutex.Unlock()
	fake.CreateCommandStub = nil
	fake.createCommandReturns = struct {
		result1 *platform.ExecCommand
	}{result1}
}

func (fake *FakePlatform) CreateCommandReturnsOnCall(i int, result1 *platform.ExecCommand) {
	fake.createCommandMutex.Lock()
	defer fake.createCommandMutex.Unlock()
	fake.CreateCommandStub = nil
	if fake.createCommandReturnsOnCall == nil {
		fake.createCommandReturnsOnCall = make(map[int]struct {
			result1 *platform.ExecCommand
		})
	}
	fake.createCommandReturnsOnCall[i] = struct {
		result1 *platform.ExecCommand
	}{result1}
}

func (fake *FakePlatform) CreateProcessGroup() *syscall.SysProcAttr {
	fake.createProcessGroupMutex.Lock()
	ret, specificReturn := fake.createProcessGroupReturnsOnCall[len(fake.createProcessGroupArgsForCall)]
	fake.createProcessGroupArgsForCall = append(fake.createProcessGroupArgsForCall, struct {
	}{})
	stub := fake.CreateProcessGroupStub
	fakeReturns := fake.createProcessGroupReturns
	fake.recordInvocation("CreateProcessGroup", []interface{}{})
	fake.createProcessGroupMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) CreateProcessGroupCallCount() int {
	fake.createProcessGroupMutex.RLock()
	defer fake.createProcessGroupMutex.RUnlock()
	return len(fake.createProcessGroupArgsForCall)
}

func (fake *FakePlatform) CreateProcessGroupCalls(stub func() *syscall.SysProcAttr) {
	fake.createProcessGroupMutex.Lock()
	defer fake.createProcessGroupMutex.Unlock()
	fake.CreateProcessGroupStub = stub
}

func (fake *FakePlatform) CreateProcessGroupReturns(result1 *syscall.SysProcAttr) {
	fake.createProcessGroupMutex.Lock()
	defer fake.createProcessGroupMutex.Unlock()
	fake.CreateProcessGroupStub = nil
	fake.createProcessGroupReturns = struct {
		result1 *syscall.SysProcAttr
	}{result1}
}

func (fake *FakePlatform) CreateProcessGroupReturnsOnCall(i int, result1 *syscall.SysProcAttr) {
	fake.createProcessGroupMutex.Lock()
	defer fake.createProcessGroupMutex.Unlock()
	fake.CreateProcessGroupStub = nil
	if fake.createProcessGroupReturnsOnCall == nil {
		fake.createProcessGroupReturnsOnCall = make(map[int]struct {
			result1 *syscall.SysProcAttr
		})
	}
	fake.createProcessGroupReturnsOnCall[i] = struct {
		result1 *syscall.SysProcAttr
	}{result1}
}

func (fake *FakePlatform) Environ() []string {
	fake.environMutex.Lock()
	ret, specificReturn := fake.environReturnsOnCall[len(fake.environArgsForCall)]
	fake.environArgsForCall = append(fake.environArgsForCall, struct {
	}{})
	stub := fake.EnvironStub
	fakeReturns := fake.environReturns
	fake.recordInvocation("Environ", []interface{}{})
	fake.environMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) EnvironCallCount() int {
	fake.environMutex.RLock()
	defer fake.environMutex.RUnlock()
	return len(fake.environArgsForCall)
}

func (fake *FakePlatform) EnvironCalls(stub func() []string) {
	fake.environMutex.Lock()
	defer fake.environMutex.Unlock()
	fake.EnvironStub = stub
}

func (fake *FakePlatform) EnvironReturns(result1 []string) {
	fake.environMutex.Lock()
	defer fake.environMutex.Unlock()
	fake.EnvironStub = nil
	fake.environReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakePlatform) EnvironReturnsOnCall(i int, result1 []string) {
	fake.environMutex.Lock()
	defer fake.environMutex.Unlock()
	fake.EnvironStub = nil
	if fake.environReturnsOnCall == nil {
		fake.environReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.environReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakePlatform) Exec(arg1 string, arg2 []string, arg3 []string) error {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.execMutex.Lock()
	ret, specificReturn := fake.execReturnsOnCall[len(fake.execArgsForCall)]
	fake.execArgsForCall = append(fake.execArgsForCall, struct {
		arg1 string
		arg2 []string
		arg3 []string
	}{arg1, arg2Copy, arg3Copy})
	stub := fake.ExecStub
	fakeReturns := fake.execReturns
	fake.recordInvocation("Exec", []interface{}{arg1, arg2Copy, arg3Copy})
	fake.execMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) ExecCallCount() int {
	fake.execMutex.RLock()
	defer fake.execMutex.RUnlock()
	return len(fake.execArgsForCall)
}

func (fake *FakePlatform) ExecCalls(stub func(string, []string, []string) error) {
	fake.execMutex.Lock()
	defer fake.execMutex.Unlock()
	fake.ExecStub = stub
}

func (fake *FakePlatform) ExecArgsForCall(i int) (string, []string, []string) {
	fake.execMutex.RLock()
	defer fake.execMutex.RUnlock()
	argsForCall := fake.execArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePlatform) ExecReturns(result1 error) {
	fake.execMutex.Lock()
	defer fake.execMutex.Unlock()
	fake.ExecStub = nil
	fake.execReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) ExecReturnsOnCall(i int, result1 error) {
	fake.execMutex.Lock()
	defer fake.execMutex.Unlock()
	fake.ExecStub = nil
	if fake.execReturnsOnCall == nil {
		fake.execReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.execReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) Executable() (string, error) {
	fake.executableMutex.Lock()
	ret, specificReturn := fake.executableReturnsOnCall[len(fake.executableArgsForCall)]
	fake.executableArgsForCall = append(fake.executableArgsForCall, struct {
	}{})
	stub := fake.ExecutableStub
	fakeReturns := fake.executableReturns
	fake.recordInvocation("Executable", []interface{}{})
	fake.executableMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePlatform) ExecutableCallCount() int {
	fake.executableMutex.RLock()
	defer fake.executableMutex.RUnlock()
	return len(fake.executableArgsForCall)
}

func (fake *FakePlatform) ExecutableCalls(stub func() (string, error)) {
	fake.executableMutex.Lock()
	defer fake.executableMutex.Unlock()
	fake.ExecutableStub = stub
}

func (fake *FakePlatform) ExecutableReturns(result1 string, result2 error) {
	fake.executableMutex.Lock()
	defer fake.executableMutex.Unlock()
	fake.ExecutableStub = nil
	fake.executableReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakePlatform) ExecutableReturnsOnCall(i int, result1 string, result2 error) {
	fake.executableMutex.Lock()
	defer fake.executableMutex.Unlock()
	fake.ExecutableStub = nil
	if fake.executableReturnsOnCall == nil {
		fake.executableReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.executableReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakePlatform) Exit(arg1 int) {
	fake.exitMutex.Lock()
	fake.exitArgsForCall = append(fake.exitArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.ExitStub
	fake.recordInvocation("Exit", []interface{}{arg1})
	fake.exitMutex.Unlock()
	if stub != nil {
		fake.ExitStub(arg1)
	}
}

func (fake *FakePlatform) ExitCallCount() int {
	fake.exitMutex.RLock()
	defer fake.exitMutex.RUnlock()
	return len(fake.exitArgsForCall)
}

func (fake *FakePlatform) ExitCalls(stub func(int)) {
	fake.exitMutex.Lock()
	defer fake.exitMutex.Unlock()
	fake.ExitStub = stub
}

func (fake *FakePlatform) ExitArgsForCall(i int) int {
	fake.exitMutex.RLock()
	defer fake.exitMutex.RUnlock()
	argsForCall := fake.exitArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePlatform) Getenv(arg1 string) string {
	fake.getenvMutex.Lock()
	ret, specificReturn := fake.getenvReturnsOnCall[len(fake.getenvArgsForCall)]
	fake.getenvArgsForCall = append(fake.getenvArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetenvStub
	fakeReturns := fake.getenvReturns
	fake.recordInvocation("Getenv", []interface{}{arg1})
	fake.getenvMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) GetenvCallCount() int {
	fake.getenvMutex.RLock()
	defer fake.getenvMutex.RUnlock()
	return len(fake.getenvArgsForCall)
}

func (fake *FakePlatform) GetenvCalls(stub func(string) string) {
	fake.getenvMutex.Lock()
	defer fake.getenvMutex.Unlock()
	fake.GetenvStub = stub
}

func (fake *FakePlatform) GetenvArgsForCall(i int) string {
	fake.getenvMutex.RLock()
	defer fake.getenvMutex.RUnlock()
	argsForCall := fake.getenvArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePlatform) GetenvReturns(result1 string) {
	fake.getenvMutex.Lock()
	defer fake.getenvMutex.Unlock()
	fake.GetenvStub = nil
	fake.getenvReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePlatform) GetenvReturnsOnCall(i int, result1 string) {
	fake.getenvMutex.Lock()
	defer fake.getenvMutex.Unlock()
	fake.GetenvStub = nil
	if fake.getenvReturnsOnCall == nil {
		fake.getenvReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getenvReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePlatform) Getpid() int {
	fake.getpidMutex.Lock()
	ret, specificReturn := fake.getpidReturnsOnCall[len(fake.getpidArgsForCall)]
	fake.getpidArgsForCall = append(fake.getpidArgsForCall, struct {
	}{})
	stub := fake.GetpidStub
	fakeReturns := fake.getpidReturns
	fake.recordInvocation("Getpid", []interface{}{})
	fake.getpidMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) GetpidCallCount() int {
	fake.getpidMutex.RLock()
	defer fake.getpidMutex.RUnlock()
	return len(fake.getpidArgsForCall)
}

func (fake *FakePlatform) GetpidCalls(stub func() int) {
	fake.getpidMutex.Lock()
	defer fake.getpidMutex.Unlock()
	fake.GetpidStub = stub
}

func (fake *FakePlatform) GetpidReturns(result1 int) {
	fake.getpidMutex.Lock()
	defer fake.getpidMutex.Unlock()
	fake.GetpidStub = nil
	fake.getpidReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakePlatform) GetpidReturnsOnCall(i int, result1 int) {
	fake.getpidMutex.Lock()
	defer fake.getpidMutex.Unlock()
	fake.GetpidStub = nil
	if fake.getpidReturnsOnCall == nil {
		fake.getpidReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.getpidReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakePlatform) IsExist(arg1 error) bool {
	fake.isExistMutex.Lock()
	ret, specificReturn := fake.isExistReturnsOnCall[len(fake.isExistArgsForCall)]
	fake.isExistArgsForCall = append(fake.isExistArgsForCall, struct {
		arg1 error
	}{arg1})
	stub := fake.IsExistStub
	fakeReturns := fake.isExistReturns
	fake.recordInvocation("IsExist", []interface{}{arg1})
	fake.isExistMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) IsExistCallCount() int {
	fake.isExistMutex.RLock()
	defer fake.isExistMutex.RUnlock()
	return len(fake.isExistArgsForCall)
}

func (fake *FakePlatform) IsExistCalls(stub func(error) bool) {
	fake.isExistMutex.Lock()
	defer fake.isExistMutex.Unlock()
	fake.IsExistStub = stub
}

func (fake *FakePlatform) IsExistArgsForCall(i int) error {
	fake.isExistMutex.RLock()
	defer fake.isExistMutex.RUnlock()
	argsForCall := fake.isExistArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePlatform) IsExistReturns(result1 bool) {
	fake.isExistMutex.Lock()
	defer fake.isExistMutex.Unlock()
	fake.IsExistStub = nil
	fake.isExistReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePlatform) IsExistReturnsOnCall(i int, result1 bool) {
	fake.isExistMutex.Lock()
	defer fake.isExistMutex.Unlock()
	fake.IsExistStub = nil
	if fake.isExistReturnsOnCall == nil {
		fake.isExistReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isExistReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePlatform) IsNotExist(arg1 error) bool {
	fake.isNotExistMutex.Lock()
	ret, specificReturn := fake.isNotExistReturnsOnCall[len(fake.isNotExistArgsForCall)]
	fake.isNotExistArgsForCall = append(fake.isNotExistArgsForCall, struct {
		arg1 error
	}{arg1})
	stub := fake.IsNotExistStub
	fakeReturns := fake.isNotExistReturns
	fake.recordInvocation("IsNotExist", []interface{}{arg1})
	fake.isNotExistMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) IsNotExistCallCount() int {
	fake.isNotExistMutex.RLock()
	defer fake.isNotExistMutex.RUnlock()
	return len(fake.isNotExistArgsForCall)
}

func (fake *FakePlatform) IsNotExistCalls(stub func(error) bool) {
	fake.isNotExistMutex.Lock()
	defer fake.isNotExistMutex.Unlock()
	fake.IsNotExistStub = stub
}

func (fake *FakePlatform) IsNotExistArgsForCall(i int) error {
	fake.isNotExistMutex.RLock()
	defer fake.isNotExistMutex.RUnlock()
	argsForCall := fake.isNotExistArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePlatform) IsNotExistReturns(result1 bool) {
	fake.isNotExistMutex.Lock()
	defer fake.isNotExistMutex.Unlock()
	fake.IsNotExistStub = nil
	fake.isNotExistReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePlatform) IsNotExistReturnsOnCall(i int, result1 bool) {
	fake.isNotExistMutex.Lock()
	defer fake.isNotExistMutex.Unlock()
	fake.IsNotExistStub = nil
	if fake.isNotExistReturnsOnCall == nil {
		fake.isNotExistReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isNotExistReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePlatform) Kill(arg1 int, arg2 syscall.Signal) error {
	fake.killMutex.Lock()
	ret, specificReturn := fake.killReturnsOnCall[len(fake.killArgsForCall)]
	fake.killArgsForCall = append(fake.killArgsForCall, struct {
		arg1 int
		arg2 syscall.Signal
	}{arg1, arg2})
	stub := fake.KillStub
	fakeReturns := fake.killReturns
	fake.recordInvocation("Kill", []interface{}{arg1, arg2})
	fake.killMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) KillCallCount() int {
	fake.killMutex.RLock()
	defer fake.killMutex.RUnlock()
	return len(fake.killArgsForCall)
}

func (fake *FakePlatform) KillCalls(stub func(int, syscall.Signal) error) {
	fake.killMutex.Lock()
	defer fake.killMutex.Unlock()
	fake.KillStub = stub
}

func (fake *FakePlatform) KillArgsForCall(i int) (int, syscall.Signal) {
	fake.killMutex.RLock()
	defer fake.killMutex.RUnlock()
	argsForCall := fake.killArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePlatform) KillReturns(result1 error) {
	fake.killMutex.Lock()
	defer fake.killMutex.Unlock()
	fake.KillStub = nil
	fake.killReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) KillReturnsOnCall(i int, result1 error) {
	fake.killMutex.Lock()
	defer fake.killMutex.Unlock()
	fake.KillStub = nil
	if fake.killReturnsOnCall == nil {
		fake.killReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.killReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) LookPath(arg1 string) (string, error) {
	fake.lookPathMutex.Lock()
	ret, specificReturn := fake.lookPathReturnsOnCall[len(fake.lookPathArgsForCall)]
	fake.lookPathArgsForCall = append(fake.lookPathArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.LookPathStub
	fakeReturns := fake.lookPathReturns
	fake.recordInvocation("LookPath", []interface{}{arg1})
	fake.lookPathMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePlatform) LookPathCallCount() int {
	fake.lookPathMutex.RLock()
	defer fake.lookPathMutex.RUnlock()
	return len(fake.lookPathArgsForCall)
}

func (fake *FakePlatform) LookPathCalls(stub func(string) (string, error)) {
	fake.lookPathMutex.Lock()
	defer fake.lookPathMutex.Unlock()
	fake.LookPathStub = stub
}

func (fake *FakePlatform) LookPathArgsForCall(i int) string {
	fake.lookPathMutex.RLock()
	defer fake.lookPathMutex.RUnlock()
	argsForCall := fake.lookPathArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePlatform) LookPathReturns(result1 string, result2 error) {
	fake.lookPathMutex.Lock()
	defer fake.lookPathMutex.Unlock()
	fake.LookPathStub = nil
	fake.lookPathReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakePlatform) LookPathReturnsOnCall(i int, result1 string, result2 error) {
	fake.lookPathMutex.Lock()
	defer fake.lookPathMutex.Unlock()
	fake.LookPathStub = nil
	if fake.lookPathReturnsOnCall == nil {
		fake.lookPathReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.lookPathReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakePlatform) MkdirAll(arg1 string, arg2 os.FileMode) error {
	fake.mkdirAllMutex.Lock()
	ret, specificReturn := fake.mkdirAllReturnsOnCall[len(fake.mkdirAllArgsForCall)]
	fake.mkdirAllArgsForCall = append(fake.mkdirAllArgsForCall, struct {
		arg1 string
		arg2 os.FileMode
	}{arg1, arg2})
	stub := fake.MkdirAllStub
	fakeReturns := fake.mkdirAllReturns
	fake.recordInvocation("MkdirAll", []interface{}{arg1, arg2})
	fake.mkdirAllMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) MkdirAllCallCount() int {
	fake.mkdirAllMutex.RLock()
	defer fake.mkdirAllMutex.RUnlock()
	return len(fake.mkdirAllArgsForCall)
}

func (fake *FakePlatform) MkdirAllCalls(stub func(string, os.FileMode) error) {
	fake.mkdirAllMutex.Lock()
	defer fake.mkdirAllMutex.Unlock()
	fake.MkdirAllStub = stub
}

func (fake *FakePlatform) MkdirAllArgsForCall(i int) (string, os.FileMode) {
	fake.mkdirAllMutex.RLock()
	defer fake.mkdirAllMutex.RUnlock()
	argsForCall := fake.mkdirAllArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePlatform) MkdirAllReturns(result1 error) {
	fake.mkdirAllMutex.Lock()
	defer fake.mkdirAllMutex.Unlock()
	fake.MkdirAllStub = nil
	fake.mkdirAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) MkdirAllReturnsOnCall(i int, result1 error) {
	fake.mkdirAllMutex.Lock()
	defer fake.mkdirAllMutex.Unlock()
	fake.MkdirAllStub = nil
	if fake.mkdirAllReturnsOnCall == nil {
		fake.mkdirAllReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mkdirAllReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) Mount(arg1 string, arg2 string, arg3 string, arg4 uintptr, arg5 string) error {
	fake.mountMutex.Lock()
	ret, specificReturn := fake.mountReturnsOnCall[len(fake.mountArgsForCall)]
	fake.mountArgsForCall = append(fake.mountArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 uintptr
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.MountStub
	fakeReturns := fake.mountReturns
	fake.recordInvocation("Mount", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.mountMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) MountCallCount() int {
	fake.mountMutex.RLock()
	defer fake.mountMutex.RUnlock()
	return len(fake.mountArgsForCall)
}

func (fake *FakePlatform) MountCalls(stub func(string, string, string, uintptr, string) error) {
	fake.mountMutex.Lock()
	defer fake.mountMutex.Unlock()
	fake.MountStub = stub
}

func (fake *FakePlatform) MountArgsForCall(i int) (string, string, string, uintptr, string) {
	fake.mountMutex.RLock()
	defer fake.mountMutex.RUnlock()
	argsForCall := fake.mountArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakePlatform) MountReturns(result1 error) {
	fake.mountMutex.Lock()
	defer fake.mountMutex.Unlock()
	fake.MountStub = nil
	fake.mountReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) MountReturnsOnCall(i int, result1 error) {
	fake.mountMutex.Lock()
	defer fake.mountMutex.Unlock()
	fake.MountStub = nil
	if fake.mountReturnsOnCall == nil {
		fake.mountReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mountReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) OpenFile(arg1 string, arg2 int, arg3 os.FileMode) (*os.File, error) {
	fake.openFileMutex.Lock()
	ret, specificReturn := fake.openFileReturnsOnCall[len(fake.openFileArgsForCall)]
	fake.openFileArgsForCall = append(fake.openFileArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 os.FileMode
	}{arg1, arg2, arg3})
	stub := fake.OpenFileStub
	fakeReturns := fake.openFileReturns
	fake.recordInvocation("OpenFile", []interface{}{arg1, arg2, arg3})
	fake.openFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePlatform) OpenFileCallCount() int {
	fake.openFileMutex.RLock()
	defer fake.openFileMutex.RUnlock()
	return len(fake.openFileArgsForCall)
}

func (fake *FakePlatform) OpenFileCalls(stub func(string, int, os.FileMode) (*os.File, error)) {
	fake.openFileMutex.Lock()
	defer fake.openFileMutex.Unlock()
	fake.OpenFileStub = stub
}

func (fake *FakePlatform) OpenFileArgsForCall(i int) (string, int, os.FileMode) {
	fake.openFileMutex.RLock()
	defer fake.openFileMutex.RUnlock()
	argsForCall := fake.openFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePlatform) OpenFileReturns(result1 *os.File, result2 error) {
	fake.openFileMutex.Lock()
	defer fake.openFileMutex.Unlock()
	fake.OpenFileStub = nil
	fake.openFileReturns = struct {
		result1 *os.File
		result2 error
	}{result1, result2}
}

func (fake *FakePlatform) OpenFileReturnsOnCall(i int, result1 *os.File, result2 error) {
	fake.openFileMutex.Lock()
	defer fake.openFileMutex.Unlock()
	fake.OpenFileStub = nil
	if fake.openFileReturnsOnCall == nil {
		fake.openFileReturnsOnCall = make(map[int]struct {
			result1 *os.File
			result2 error
		})
	}
	fake.openFileReturnsOnCall[i] = struct {
		result1 *os.File
		result2 error
	}{result1, result2}
}

func (fake *FakePlatform) ReadDir(arg1 string) ([]os.DirEntry, error) {
	fake.readDirMutex.Lock()
	ret, specificReturn := fake.readDirReturnsOnCall[len(fake.readDirArgsForCall)]
	fake.readDirArgsForCall = append(fake.readDirArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ReadDirStub
	fakeReturns := fake.readDirReturns
	fake.recordInvocation("ReadDir", []interface{}{arg1})
	fake.readDirMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePlatform) ReadDirCallCount() int {
	fake.readDirMutex.RLock()
	defer fake.readDirMutex.RUnlock()
	return len(fake.readDirArgsForCall)
}

func (fake *FakePlatform) ReadDirCalls(stub func(string) ([]os.DirEntry, error)) {
	fake.readDirMutex.Lock()
	defer fake.readDirMutex.Unlock()
	fake.ReadDirStub = stub
}

func (fake *FakePlatform) ReadDirArgsForCall(i int) string {
	fake.readDirMutex.RLock()
	defer fake.readDirMutex.RUnlock()
	argsForCall := fake.readDirArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePlatform) ReadDirReturns(result1 []os.DirEntry, result2 error) {
	fake.readDirMutex.Lock()
	defer fake.readDirMutex.Unlock()
	fake.ReadDirStub = nil
	fake.readDirReturns = struct {
		result1 []os.DirEntry
		result2 error
	}{result1, result2}
}

func (fake *FakePlatform) ReadDirReturnsOnCall(i int, result1 []os.DirEntry, result2 error) {
	fake.readDirMutex.Lock()
	defer fake.readDirMutex.Unlock()
	fake.ReadDirStub = nil
	if fake.readDirReturnsOnCall == nil {
		fake.readDirReturnsOnCall = make(map[int]struct {
			result1 []os.DirEntry
			result2 error
		})
	}
	fake.readDirReturnsOnCall[i] = struct {
		result1 []os.DirEntry
		result2 error
	}{result1, result2}
}

func (fake *FakePlatform) ReadFile(arg1 string) ([]byte, error) {
	fake.readFileMutex.Lock()
	ret, specificReturn := fake.readFileReturnsOnCall[len(fake.readFileArgsForCall)]
	fake.readFileArgsForCall = append(fake.readFileArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ReadFileStub
	fakeReturns := fake.readFileReturns
	fake.recordInvocation("ReadFile", []interface{}{arg1})
	fake.readFileMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePlatform) ReadFileCallCount() int {
	fake.readFileMutex.RLock()
	defer fake.readFileMutex.RUnlock()
	return len(fake.readFileArgsForCall)
}

func (fake *FakePlatform) ReadFileCalls(stub func(string) ([]byte, error)) {
	fake.readFileMutex.Lock()
	defer fake.readFileMutex.Unlock()
	fake.ReadFileStub = stub
}

func (fake *FakePlatform) ReadFileArgsForCall(i int) string {
	fake.readFileMutex.RLock()
	defer fake.readFileMutex.RUnlock()
	argsForCall := fake.readFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePlatform) ReadFileReturns(result1 []byte, result2 error) {
	fake.readFileMutex.Lock()
	defer fake.readFileMutex.Unlock()
	fake.ReadFileStub = nil
	fake.readFileReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakePlatform) ReadFileReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.readFileMutex.Lock()
	defer fake.readFileMutex.Unlock()
	fake.ReadFileStub = nil
	if fake.readFileReturnsOnCall == nil {
		fake.readFileReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.readFileReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakePlatform) Remove(arg1 string) error {
	fake.removeMutex.Lock()
	ret, specificReturn := fake.removeReturnsOnCall[len(fake.removeArgsForCall)]
	fake.removeArgsForCall = append(fake.removeArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RemoveStub
	fakeReturns := fake.removeReturns
	fake.recordInvocation("Remove", []interface{}{arg1})
	fake.removeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) RemoveCallCount() int {
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	return len(fake.removeArgsForCall)
}

func (fake *FakePlatform) RemoveCalls(stub func(string) error) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = stub
}

func (fake *FakePlatform) RemoveArgsForCall(i int) string {
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	argsForCall := fake.removeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePlatform) RemoveReturns(result1 error) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = nil
	fake.removeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) RemoveReturnsOnCall(i int, result1 error) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = nil
	if fake.removeReturnsOnCall == nil {
		fake.removeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) RemoveAll(arg1 string) error {
	fake.removeAllMutex.Lock()
	ret, specificReturn := fake.removeAllReturnsOnCall[len(fake.removeAllArgsForCall)]
	fake.removeAllArgsForCall = append(fake.removeAllArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RemoveAllStub
	fakeReturns := fake.removeAllReturns
	fake.recordInvocation("RemoveAll", []interface{}{arg1})
	fake.removeAllMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) RemoveAllCallCount() int {
	fake.removeAllMutex.RLock()
	defer fake.removeAllMutex.RUnlock()
	return len(fake.removeAllArgsForCall)
}

func (fake *FakePlatform) RemoveAllCalls(stub func(string) error) {
	fake.removeAllMutex.Lock()
	defer fake.removeAllMutex.Unlock()
	fake.RemoveAllStub = stub
}

func (fake *FakePlatform) RemoveAllArgsForCall(i int) string {
	fake.removeAllMutex.RLock()
	defer fake.removeAllMutex.RUnlock()
	argsForCall := fake.removeAllArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePlatform) RemoveAllReturns(result1 error) {
	fake.removeAllMutex.Lock()
	defer fake.removeAllMutex.Unlock()
	fake.RemoveAllStub = nil
	fake.removeAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) RemoveAllReturnsOnCall(i int, result1 error) {
	fake.removeAllMutex.Lock()
	defer fake.removeAllMutex.Unlock()
	fake.RemoveAllStub = nil
	if fake.removeAllReturnsOnCall == nil {
		fake.removeAllReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeAllReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) Stat(arg1 string) (os.FileInfo, error) {
	fake.statMutex.Lock()
	ret, specificReturn := fake.statReturnsOnCall[len(fake.statArgsForCall)]
	fake.statArgsForCall = append(fake.statArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.StatStub
	fakeReturns := fake.statReturns
	fake.recordInvocation("Stat", []interface{}{arg1})
	fake.statMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePlatform) StatCallCount() int {
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	return len(fake.statArgsForCall)
}

func (fake *FakePlatform) StatCalls(stub func(string) (os.FileInfo, error)) {
	fake.statMutex.Lock()
	defer fake.statMutex.Unlock()
	fake.StatStub = stub
}

func (fake *FakePlatform) StatArgsForCall(i int) string {
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	argsForCall := fake.statArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePlatform) StatReturns(result1 os.FileInfo, result2 error) {
	fake.statMutex.Lock()
	defer fake.statMutex.Unlock()
	fake.StatStub = nil
	fake.statReturns = struct {
		result1 os.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakePlatform) StatReturnsOnCall(i int, result1 os.FileInfo, result2 error) {
	fake.statMutex.Lock()
	defer fake.statMutex.Unlock()
	fake.StatStub = nil
	if fake.statReturnsOnCall == nil {
		fake.statReturnsOnCall = make(map[int]struct {
			result1 os.FileInfo
			result2 error
		})
	}
	fake.statReturnsOnCall[i] = struct {
		result1 os.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakePlatform) Symlink(arg1 string, arg2 string) error {
	fake.symlinkMutex.Lock()
	ret, specificReturn := fake.symlinkReturnsOnCall[len(fake.symlinkArgsForCall)]
	fake.symlinkArgsForCall = append(fake.symlinkArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.SymlinkStub
	fakeReturns := fake.symlinkReturns
	fake.recordInvocation("Symlink", []interface{}{arg1, arg2})
	fake.symlinkMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) SymlinkCallCount() int {
	fake.symlinkMutex.RLock()
	defer fake.symlinkMutex.RUnlock()
	return len(fake.symlinkArgsForCall)
}

func (fake *FakePlatform) SymlinkCalls(stub func(string, string) error) {
	fake.symlinkMutex.Lock()
	defer fake.symlinkMutex.Unlock()
	fake.SymlinkStub = stub
}

func (fake *FakePlatform) SymlinkArgsForCall(i int) (string, string) {
	fake.symlinkMutex.RLock()
	defer fake.symlinkMutex.RUnlock()
	argsForCall := fake.symlinkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePlatform) SymlinkReturns(result1 error) {
	fake.symlinkMutex.Lock()
	defer fake.symlinkMutex.Unlock()
	fake.SymlinkStub = nil
	fake.symlinkReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SymlinkReturnsOnCall(i int, result1 error) {
	fake.symlinkMutex.Lock()
	defer fake.symlinkMutex.Unlock()
	fake.SymlinkStub = nil
	if fake.symlinkReturnsOnCall == nil {
		fake.symlinkReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.symlinkReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) Unmount(arg1 string, arg2 int) error {
	fake.unmountMutex.Lock()
	ret, specificReturn := fake.unmountReturnsOnCall[len(fake.unmountArgsForCall)]
	fake.unmountArgsForCall = append(fake.unmountArgsForCall, struct {
		arg1 string
		arg2 int
	}{arg1, arg2})
	stub := fake.UnmountStub
	fakeReturns := fake.unmountReturns
	fake.recordInvocation("Unmount", []interface{}{arg1, arg2})
	fake.unmountMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) UnmountCallCount() int {
	fake.unmountMutex.RLock()
	defer fake.unmountMutex.RUnlock()
	return len(fake.unmountArgsForCall)
}

func (fake *FakePlatform) UnmountCalls(stub func(string, int) error) {
	fake.unmountMutex.Lock()
	defer fake.unmountMutex.Unlock()
	fake.UnmountStub = stub
}

func (fake *FakePlatform) UnmountArgsForCall(i int) (string, int) {
	fake.unmountMutex.RLock()
	defer fake.unmountMutex.RUnlock()
	argsForCall := fake.unmountArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePlatform) UnmountReturns(result1 error) {
	fake.unmountMutex.Lock()
	defer fake.unmountMutex.Unlock()
	fake.UnmountStub = nil
	fake.unmountReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) UnmountReturnsOnCall(i int, result1 error) {
	fake.unmountMutex.Lock()
	defer fake.unmountMutex.Unlock()
	fake.UnmountStub = nil
	if fake.unmountReturnsOnCall == nil {
		fake.unmountReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unmountReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) WriteFile(arg1 string, arg2 []byte, arg3 os.FileMode) error {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.writeFileMutex.Lock()
	ret, specificReturn := fake.writeFileReturnsOnCall[len(fake.writeFileArgsForCall)]
	fake.writeFileArgsForCall = append(fake.writeFileArgsForCall, struct {
		arg1 string
		arg2 []byte
		arg3 os.FileMode
	}{arg1, arg2Copy, arg3})
	stub := fake.WriteFileStub
	fakeReturns := fake.writeFileReturns
	fake.recordInvocation("WriteFile", []interface{}{arg1, arg2Copy, arg3})
	fake.writeFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) WriteFileCallCount() int {
	fake.writeFileMutex.RLock()
	defer fake.writeFileMutex.RUnlock()
	return len(fake.writeFileArgsForCall)
}

func (fake *FakePlatform) WriteFileCalls(stub func(string, []byte, os.FileMode) error) {
	fake.writeFileMutex.Lock()
	defer fake.writeFileMutex.Unlock()
	fake.WriteFileStub = stub
}

func (fake *FakePlatform) WriteFileArgsForCall(i int) (string, []byte, os.FileMode) {
	fake.writeFileMutex.RLock()
	defer fake.writeFileMutex.RUnlock()
	argsForCall := fake.writeFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePlatform) WriteFileReturns(result1 error) {
	fake.writeFileMutex.Lock()
	defer fake.writeFileMutex.Unlock()
	fake.WriteFileStub = nil
	fake.writeFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) WriteFileReturnsOnCall(i int, result1 error) {
	fake.writeFileMutex.Lock()
	defer fake.writeFileMutex.Unlock()
	fake.WriteFileStub = nil
	if fake.writeFileReturnsOnCall == nil {
		fake.writeFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.writeFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePlatform) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ platform.Platform = new(FakePlatform)
