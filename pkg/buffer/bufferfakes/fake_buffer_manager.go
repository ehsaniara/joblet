// Code generated by counterfeiter. DO NOT EDIT.
package bufferfakes

import (
	"context"
	"joblet/pkg/buffer"
	"sync"
)

type FakeBufferManager struct {
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	closeReturns struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	CreateBufferStub        func(context.Context, string, buffer.BufferConfig) (buffer.Buffer, error)
	createBufferMutex       sync.RWMutex
	createBufferArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 buffer.BufferConfig
	}
	createBufferReturns struct {
		result1 buffer.Buffer
		result2 error
	}
	createBufferReturnsOnCall map[int]struct {
		result1 buffer.Buffer
		result2 error
	}
	CreatePersistentBufferStub        func(context.Context, string, string, buffer.BufferConfig) (buffer.PersistentBuffer, error)
	createPersistentBufferMutex       sync.RWMutex
	createPersistentBufferArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 buffer.BufferConfig
	}
	createPersistentBufferReturns struct {
		result1 buffer.PersistentBuffer
		result2 error
	}
	createPersistentBufferReturnsOnCall map[int]struct {
		result1 buffer.PersistentBuffer
		result2 error
	}
	CreateRingBufferStub        func(context.Context, string, int, buffer.BufferConfig) (buffer.RingBuffer, error)
	createRingBufferMutex       sync.RWMutex
	createRingBufferArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int
		arg4 buffer.BufferConfig
	}
	createRingBufferReturns struct {
		result1 buffer.RingBuffer
		result2 error
	}
	createRingBufferReturnsOnCall map[int]struct {
		result1 buffer.RingBuffer
		result2 error
	}
	GetBufferStub        func(string) (buffer.Buffer, bool)
	getBufferMutex       sync.RWMutex
	getBufferArgsForCall []struct {
		arg1 string
	}
	getBufferReturns struct {
		result1 buffer.Buffer
		result2 bool
	}
	getBufferReturnsOnCall map[int]struct {
		result1 buffer.Buffer
		result2 bool
	}
	ListBuffersStub        func() []string
	listBuffersMutex       sync.RWMutex
	listBuffersArgsForCall []struct {
	}
	listBuffersReturns struct {
		result1 []string
	}
	listBuffersReturnsOnCall map[int]struct {
		result1 []string
	}
	RemoveBufferStub        func(string) error
	removeBufferMutex       sync.RWMutex
	removeBufferArgsForCall []struct {
		arg1 string
	}
	removeBufferReturns struct {
		result1 error
	}
	removeBufferReturnsOnCall map[int]struct {
		result1 error
	}
	StatsStub        func() *buffer.BufferManagerStats
	statsMutex       sync.RWMutex
	statsArgsForCall []struct {
	}
	statsReturns struct {
		result1 *buffer.BufferManagerStats
	}
	statsReturnsOnCall map[int]struct {
		result1 *buffer.BufferManagerStats
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeBufferManager) Close() error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	stub := fake.CloseStub
	fakeReturns := fake.closeReturns
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBufferManager) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeBufferManager) CloseCalls(stub func() error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeBufferManager) CloseReturns(result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBufferManager) CloseReturnsOnCall(i int, result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBufferManager) CreateBuffer(arg1 context.Context, arg2 string, arg3 buffer.BufferConfig) (buffer.Buffer, error) {
	fake.createBufferMutex.Lock()
	ret, specificReturn := fake.createBufferReturnsOnCall[len(fake.createBufferArgsForCall)]
	fake.createBufferArgsForCall = append(fake.createBufferArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 buffer.BufferConfig
	}{arg1, arg2, arg3})
	stub := fake.CreateBufferStub
	fakeReturns := fake.createBufferReturns
	fake.recordInvocation("CreateBuffer", []interface{}{arg1, arg2, arg3})
	fake.createBufferMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBufferManager) CreateBufferCallCount() int {
	fake.createBufferMutex.RLock()
	defer fake.createBufferMutex.RUnlock()
	return len(fake.createBufferArgsForCall)
}

func (fake *FakeBufferManager) CreateBufferCalls(stub func(context.Context, string, buffer.BufferConfig) (buffer.Buffer, error)) {
	fake.createBufferMutex.Lock()
	defer fake.createBufferMutex.Unlock()
	fake.CreateBufferStub = stub
}

func (fake *FakeBufferManager) CreateBufferArgsForCall(i int) (context.Context, string, buffer.BufferConfig) {
	fake.createBufferMutex.RLock()
	defer fake.createBufferMutex.RUnlock()
	argsForCall := fake.createBufferArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBufferManager) CreateBufferReturns(result1 buffer.Buffer, result2 error) {
	fake.createBufferMutex.Lock()
	defer fake.createBufferMutex.Unlock()
	fake.CreateBufferStub = nil
	fake.createBufferReturns = struct {
		result1 buffer.Buffer
		result2 error
	}{result1, result2}
}

func (fake *FakeBufferManager) CreateBufferReturnsOnCall(i int, result1 buffer.Buffer, result2 error) {
	fake.createBufferMutex.Lock()
	defer fake.createBufferMutex.Unlock()
	fake.CreateBufferStub = nil
	if fake.createBufferReturnsOnCall == nil {
		fake.createBufferReturnsOnCall = make(map[int]struct {
			result1 buffer.Buffer
			result2 error
		})
	}
	fake.createBufferReturnsOnCall[i] = struct {
		result1 buffer.Buffer
		result2 error
	}{result1, result2}
}

func (fake *FakeBufferManager) CreatePersistentBuffer(arg1 context.Context, arg2 string, arg3 string, arg4 buffer.BufferConfig) (buffer.PersistentBuffer, error) {
	fake.createPersistentBufferMutex.Lock()
	ret, specificReturn := fake.createPersistentBufferReturnsOnCall[len(fake.createPersistentBufferArgsForCall)]
	fake.createPersistentBufferArgsForCall = append(fake.createPersistentBufferArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 buffer.BufferConfig
	}{arg1, arg2, arg3, arg4})
	stub := fake.CreatePersistentBufferStub
	fakeReturns := fake.createPersistentBufferReturns
	fake.recordInvocation("CreatePersistentBuffer", []interface{}{arg1, arg2, arg3, arg4})
	fake.createPersistentBufferMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBufferManager) CreatePersistentBufferCallCount() int {
	fake.createPersistentBufferMutex.RLock()
	defer fake.createPersistentBufferMutex.RUnlock()
	return len(fake.createPersistentBufferArgsForCall)
}

func (fake *FakeBufferManager) CreatePersistentBufferCalls(stub func(context.Context, string, string, buffer.BufferConfig) (buffer.PersistentBuffer, error)) {
	fake.createPersistentBufferMutex.Lock()
	defer fake.createPersistentBufferMutex.Unlock()
	fake.CreatePersistentBufferStub = stub
}

func (fake *FakeBufferManager) CreatePersistentBufferArgsForCall(i int) (context.Context, string, string, buffer.BufferConfig) {
	fake.createPersistentBufferMutex.RLock()
	defer fake.createPersistentBufferMutex.RUnlock()
	argsForCall := fake.createPersistentBufferArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeBufferManager) CreatePersistentBufferReturns(result1 buffer.PersistentBuffer, result2 error) {
	fake.createPersistentBufferMutex.Lock()
	defer fake.createPersistentBufferMutex.Unlock()
	fake.CreatePersistentBufferStub = nil
	fake.createPersistentBufferReturns = struct {
		result1 buffer.PersistentBuffer
		result2 error
	}{result1, result2}
}

func (fake *FakeBufferManager) CreatePersistentBufferReturnsOnCall(i int, result1 buffer.PersistentBuffer, result2 error) {
	fake.createPersistentBufferMutex.Lock()
	defer fake.createPersistentBufferMutex.Unlock()
	fake.CreatePersistentBufferStub = nil
	if fake.createPersistentBufferReturnsOnCall == nil {
		fake.createPersistentBufferReturnsOnCall = make(map[int]struct {
			result1 buffer.PersistentBuffer
			result2 error
		})
	}
	fake.createPersistentBufferReturnsOnCall[i] = struct {
		result1 buffer.PersistentBuffer
		result2 error
	}{result1, result2}
}

func (fake *FakeBufferManager) CreateRingBuffer(arg1 context.Context, arg2 string, arg3 int, arg4 buffer.BufferConfig) (buffer.RingBuffer, error) {
	fake.createRingBufferMutex.Lock()
	ret, specificReturn := fake.createRingBufferReturnsOnCall[len(fake.createRingBufferArgsForCall)]
	fake.createRingBufferArgsForCall = append(fake.createRingBufferArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int
		arg4 buffer.BufferConfig
	}{arg1, arg2, arg3, arg4})
	stub := fake.CreateRingBufferStub
	fakeReturns := fake.createRingBufferReturns
	fake.recordInvocation("CreateRingBuffer", []interface{}{arg1, arg2, arg3, arg4})
	fake.createRingBufferMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBufferManager) CreateRingBufferCallCount() int {
	fake.createRingBufferMutex.RLock()
	defer fake.createRingBufferMutex.RUnlock()
	return len(fake.createRingBufferArgsForCall)
}

func (fake *FakeBufferManager) CreateRingBufferCalls(stub func(context.Context, string, int, buffer.BufferConfig) (buffer.RingBuffer, error)) {
	fake.createRingBufferMutex.Lock()
	defer fake.createRingBufferMutex.Unlock()
	fake.CreateRingBufferStub = stub
}

func (fake *FakeBufferManager) CreateRingBufferArgsForCall(i int) (context.Context, string, int, buffer.BufferConfig) {
	fake.createRingBufferMutex.RLock()
	defer fake.createRingBufferMutex.RUnlock()
	argsForCall := fake.createRingBufferArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeBufferManager) CreateRingBufferReturns(result1 buffer.RingBuffer, result2 error) {
	fake.createRingBufferMutex.Lock()
	defer fake.createRingBufferMutex.Unlock()
	fake.CreateRingBufferStub = nil
	fake.createRingBufferReturns = struct {
		result1 buffer.RingBuffer
		result2 error
	}{result1, result2}
}

func (fake *FakeBufferManager) CreateRingBufferReturnsOnCall(i int, result1 buffer.RingBuffer, result2 error) {
	fake.createRingBufferMutex.Lock()
	defer fake.createRingBufferMutex.Unlock()
	fake.CreateRingBufferStub = nil
	if fake.createRingBufferReturnsOnCall == nil {
		fake.createRingBufferReturnsOnCall = make(map[int]struct {
			result1 buffer.RingBuffer
			result2 error
		})
	}
	fake.createRingBufferReturnsOnCall[i] = struct {
		result1 buffer.RingBuffer
		result2 error
	}{result1, result2}
}

func (fake *FakeBufferManager) GetBuffer(arg1 string) (buffer.Buffer, bool) {
	fake.getBufferMutex.Lock()
	ret, specificReturn := fake.getBufferReturnsOnCall[len(fake.getBufferArgsForCall)]
	fake.getBufferArgsForCall = append(fake.getBufferArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetBufferStub
	fakeReturns := fake.getBufferReturns
	fake.recordInvocation("GetBuffer", []interface{}{arg1})
	fake.getBufferMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBufferManager) GetBufferCallCount() int {
	fake.getBufferMutex.RLock()
	defer fake.getBufferMutex.RUnlock()
	return len(fake.getBufferArgsForCall)
}

func (fake *FakeBufferManager) GetBufferCalls(stub func(string) (buffer.Buffer, bool)) {
	fake.getBufferMutex.Lock()
	defer fake.getBufferMutex.Unlock()
	fake.GetBufferStub = stub
}

func (fake *FakeBufferManager) GetBufferArgsForCall(i int) string {
	fake.getBufferMutex.RLock()
	defer fake.getBufferMutex.RUnlock()
	argsForCall := fake.getBufferArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBufferManager) GetBufferReturns(result1 buffer.Buffer, result2 bool) {
	fake.getBufferMutex.Lock()
	defer fake.getBufferMutex.Unlock()
	fake.GetBufferStub = nil
	fake.getBufferReturns = struct {
		result1 buffer.Buffer
		result2 bool
	}{result1, result2}
}

func (fake *FakeBufferManager) GetBufferReturnsOnCall(i int, result1 buffer.Buffer, result2 bool) {
	fake.getBufferMutex.Lock()
	defer fake.getBufferMutex.Unlock()
	fake.GetBufferStub = nil
	if fake.getBufferReturnsOnCall == nil {
		fake.getBufferReturnsOnCall = make(map[int]struct {
			result1 buffer.Buffer
			result2 bool
		})
	}
	fake.getBufferReturnsOnCall[i] = struct {
		result1 buffer.Buffer
		result2 bool
	}{result1, result2}
}

func (fake *FakeBufferManager) ListBuffers() []string {
	fake.listBuffersMutex.Lock()
	ret, specificReturn := fake.listBuffersReturnsOnCall[len(fake.listBuffersArgsForCall)]
	fake.listBuffersArgsForCall = append(fake.listBuffersArgsForCall, struct {
	}{})
	stub := fake.ListBuffersStub
	fakeReturns := fake.listBuffersReturns
	fake.recordInvocation("ListBuffers", []interface{}{})
	fake.listBuffersMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBufferManager) ListBuffersCallCount() int {
	fake.listBuffersMutex.RLock()
	defer fake.listBuffersMutex.RUnlock()
	return len(fake.listBuffersArgsForCall)
}

func (fake *FakeBufferManager) ListBuffersCalls(stub func() []string) {
	fake.listBuffersMutex.Lock()
	defer fake.listBuffersMutex.Unlock()
	fake.ListBuffersStub = stub
}

func (fake *FakeBufferManager) ListBuffersReturns(result1 []string) {
	fake.listBuffersMutex.Lock()
	defer fake.listBuffersMutex.Unlock()
	fake.ListBuffersStub = nil
	fake.listBuffersReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeBufferManager) ListBuffersReturnsOnCall(i int, result1 []string) {
	fake.listBuffersMutex.Lock()
	defer fake.listBuffersMutex.Unlock()
	fake.ListBuffersStub = nil
	if fake.listBuffersReturnsOnCall == nil {
		fake.listBuffersReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.listBuffersReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeBufferManager) RemoveBuffer(arg1 string) error {
	fake.removeBufferMutex.Lock()
	ret, specificReturn := fake.removeBufferReturnsOnCall[len(fake.removeBufferArgsForCall)]
	fake.removeBufferArgsForCall = append(fake.removeBufferArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RemoveBufferStub
	fakeReturns := fake.removeBufferReturns
	fake.recordInvocation("RemoveBuffer", []interface{}{arg1})
	fake.removeBufferMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBufferManager) RemoveBufferCallCount() int {
	fake.removeBufferMutex.RLock()
	defer fake.removeBufferMutex.RUnlock()
	return len(fake.removeBufferArgsForCall)
}

func (fake *FakeBufferManager) RemoveBufferCalls(stub func(string) error) {
	fake.removeBufferMutex.Lock()
	defer fake.removeBufferMutex.Unlock()
	fake.RemoveBufferStub = stub
}

func (fake *FakeBufferManager) RemoveBufferArgsForCall(i int) string {
	fake.removeBufferMutex.RLock()
	defer fake.removeBufferMutex.RUnlock()
	argsForCall := fake.removeBufferArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBufferManager) RemoveBufferReturns(result1 error) {
	fake.removeBufferMutex.Lock()
	defer fake.removeBufferMutex.Unlock()
	fake.RemoveBufferStub = nil
	fake.removeBufferReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBufferManager) RemoveBufferReturnsOnCall(i int, result1 error) {
	fake.removeBufferMutex.Lock()
	defer fake.removeBufferMutex.Unlock()
	fake.RemoveBufferStub = nil
	if fake.removeBufferReturnsOnCall == nil {
		fake.removeBufferReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeBufferReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBufferManager) Stats() *buffer.BufferManagerStats {
	fake.statsMutex.Lock()
	ret, specificReturn := fake.statsReturnsOnCall[len(fake.statsArgsForCall)]
	fake.statsArgsForCall = append(fake.statsArgsForCall, struct {
	}{})
	stub := fake.StatsStub
	fakeReturns := fake.statsReturns
	fake.recordInvocation("Stats", []interface{}{})
	fake.statsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBufferManager) StatsCallCount() int {
	fake.statsMutex.RLock()
	defer fake.statsMutex.RUnlock()
	return len(fake.statsArgsForCall)
}

func (fake *FakeBufferManager) StatsCalls(stub func() *buffer.BufferManagerStats) {
	fake.statsMutex.Lock()
	defer fake.statsMutex.Unlock()
	fake.StatsStub = stub
}

func (fake *FakeBufferManager) StatsReturns(result1 *buffer.BufferManagerStats) {
	fake.statsMutex.Lock()
	defer fake.statsMutex.Unlock()
	fake.StatsStub = nil
	fake.statsReturns = struct {
		result1 *buffer.BufferManagerStats
	}{result1}
}

func (fake *FakeBufferManager) StatsReturnsOnCall(i int, result1 *buffer.BufferManagerStats) {
	fake.statsMutex.Lock()
	defer fake.statsMutex.Unlock()
	fake.StatsStub = nil
	if fake.statsReturnsOnCall == nil {
		fake.statsReturnsOnCall = make(map[int]struct {
			result1 *buffer.BufferManagerStats
		})
	}
	fake.statsReturnsOnCall[i] = struct {
		result1 *buffer.BufferManagerStats
	}{result1}
}

func (fake *FakeBufferManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeBufferManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ buffer.BufferManager = new(FakeBufferManager)
