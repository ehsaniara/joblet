// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.1
// source: joblet.proto

package __

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	JobletService_RunJob_FullMethodName       = "/joblet.JobletService/RunJob"
	JobletService_GetJobStatus_FullMethodName = "/joblet.JobletService/GetJobStatus"
	JobletService_StopJob_FullMethodName      = "/joblet.JobletService/StopJob"
	JobletService_GetJobLogs_FullMethodName   = "/joblet.JobletService/GetJobLogs"
	JobletService_ListJobs_FullMethodName     = "/joblet.JobletService/ListJobs"
)

// JobletServiceClient is the client API for JobletService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Job execution service
type JobletServiceClient interface {
	RunJob(ctx context.Context, in *RunJobReq, opts ...grpc.CallOption) (*RunJobRes, error)
	GetJobStatus(ctx context.Context, in *GetJobStatusReq, opts ...grpc.CallOption) (*GetJobStatusRes, error)
	StopJob(ctx context.Context, in *StopJobReq, opts ...grpc.CallOption) (*StopJobRes, error)
	GetJobLogs(ctx context.Context, in *GetJobLogsReq, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DataChunk], error)
	ListJobs(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*Jobs, error)
}

type jobletServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewJobletServiceClient(cc grpc.ClientConnInterface) JobletServiceClient {
	return &jobletServiceClient{cc}
}

func (c *jobletServiceClient) RunJob(ctx context.Context, in *RunJobReq, opts ...grpc.CallOption) (*RunJobRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RunJobRes)
	err := c.cc.Invoke(ctx, JobletService_RunJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobletServiceClient) GetJobStatus(ctx context.Context, in *GetJobStatusReq, opts ...grpc.CallOption) (*GetJobStatusRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetJobStatusRes)
	err := c.cc.Invoke(ctx, JobletService_GetJobStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobletServiceClient) StopJob(ctx context.Context, in *StopJobReq, opts ...grpc.CallOption) (*StopJobRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StopJobRes)
	err := c.cc.Invoke(ctx, JobletService_StopJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobletServiceClient) GetJobLogs(ctx context.Context, in *GetJobLogsReq, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DataChunk], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &JobletService_ServiceDesc.Streams[0], JobletService_GetJobLogs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetJobLogsReq, DataChunk]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type JobletService_GetJobLogsClient = grpc.ServerStreamingClient[DataChunk]

func (c *jobletServiceClient) ListJobs(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*Jobs, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Jobs)
	err := c.cc.Invoke(ctx, JobletService_ListJobs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// JobletServiceServer is the server API for JobletService service.
// All implementations must embed UnimplementedJobletServiceServer
// for forward compatibility.
//
// Job execution service
type JobletServiceServer interface {
	RunJob(context.Context, *RunJobReq) (*RunJobRes, error)
	GetJobStatus(context.Context, *GetJobStatusReq) (*GetJobStatusRes, error)
	StopJob(context.Context, *StopJobReq) (*StopJobRes, error)
	GetJobLogs(*GetJobLogsReq, grpc.ServerStreamingServer[DataChunk]) error
	ListJobs(context.Context, *EmptyRequest) (*Jobs, error)
	mustEmbedUnimplementedJobletServiceServer()
}

// UnimplementedJobletServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedJobletServiceServer struct{}

func (UnimplementedJobletServiceServer) RunJob(context.Context, *RunJobReq) (*RunJobRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunJob not implemented")
}
func (UnimplementedJobletServiceServer) GetJobStatus(context.Context, *GetJobStatusReq) (*GetJobStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetJobStatus not implemented")
}
func (UnimplementedJobletServiceServer) StopJob(context.Context, *StopJobReq) (*StopJobRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopJob not implemented")
}
func (UnimplementedJobletServiceServer) GetJobLogs(*GetJobLogsReq, grpc.ServerStreamingServer[DataChunk]) error {
	return status.Errorf(codes.Unimplemented, "method GetJobLogs not implemented")
}
func (UnimplementedJobletServiceServer) ListJobs(context.Context, *EmptyRequest) (*Jobs, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListJobs not implemented")
}
func (UnimplementedJobletServiceServer) mustEmbedUnimplementedJobletServiceServer() {}
func (UnimplementedJobletServiceServer) testEmbeddedByValue()                       {}

// UnsafeJobletServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to JobletServiceServer will
// result in compilation errors.
type UnsafeJobletServiceServer interface {
	mustEmbedUnimplementedJobletServiceServer()
}

func RegisterJobletServiceServer(s grpc.ServiceRegistrar, srv JobletServiceServer) {
	// If the following call pancis, it indicates UnimplementedJobletServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&JobletService_ServiceDesc, srv)
}

func _JobletService_RunJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunJobReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobletServiceServer).RunJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobletService_RunJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobletServiceServer).RunJob(ctx, req.(*RunJobReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobletService_GetJobStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetJobStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobletServiceServer).GetJobStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobletService_GetJobStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobletServiceServer).GetJobStatus(ctx, req.(*GetJobStatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobletService_StopJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopJobReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobletServiceServer).StopJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobletService_StopJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobletServiceServer).StopJob(ctx, req.(*StopJobReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobletService_GetJobLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetJobLogsReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(JobletServiceServer).GetJobLogs(m, &grpc.GenericServerStream[GetJobLogsReq, DataChunk]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type JobletService_GetJobLogsServer = grpc.ServerStreamingServer[DataChunk]

func _JobletService_ListJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobletServiceServer).ListJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobletService_ListJobs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobletServiceServer).ListJobs(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// JobletService_ServiceDesc is the grpc.ServiceDesc for JobletService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var JobletService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "joblet.JobletService",
	HandlerType: (*JobletServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RunJob",
			Handler:    _JobletService_RunJob_Handler,
		},
		{
			MethodName: "GetJobStatus",
			Handler:    _JobletService_GetJobStatus_Handler,
		},
		{
			MethodName: "StopJob",
			Handler:    _JobletService_StopJob_Handler,
		},
		{
			MethodName: "ListJobs",
			Handler:    _JobletService_ListJobs_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetJobLogs",
			Handler:       _JobletService_GetJobLogs_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "joblet.proto",
}

const (
	NetworkService_CreateNetwork_FullMethodName = "/joblet.NetworkService/CreateNetwork"
	NetworkService_ListNetworks_FullMethodName  = "/joblet.NetworkService/ListNetworks"
	NetworkService_RemoveNetwork_FullMethodName = "/joblet.NetworkService/RemoveNetwork"
)

// NetworkServiceClient is the client API for NetworkService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Network management service
type NetworkServiceClient interface {
	CreateNetwork(ctx context.Context, in *CreateNetworkReq, opts ...grpc.CallOption) (*CreateNetworkRes, error)
	ListNetworks(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*Networks, error)
	RemoveNetwork(ctx context.Context, in *RemoveNetworkReq, opts ...grpc.CallOption) (*RemoveNetworkRes, error)
}

type networkServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNetworkServiceClient(cc grpc.ClientConnInterface) NetworkServiceClient {
	return &networkServiceClient{cc}
}

func (c *networkServiceClient) CreateNetwork(ctx context.Context, in *CreateNetworkReq, opts ...grpc.CallOption) (*CreateNetworkRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateNetworkRes)
	err := c.cc.Invoke(ctx, NetworkService_CreateNetwork_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkServiceClient) ListNetworks(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*Networks, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Networks)
	err := c.cc.Invoke(ctx, NetworkService_ListNetworks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkServiceClient) RemoveNetwork(ctx context.Context, in *RemoveNetworkReq, opts ...grpc.CallOption) (*RemoveNetworkRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveNetworkRes)
	err := c.cc.Invoke(ctx, NetworkService_RemoveNetwork_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NetworkServiceServer is the server API for NetworkService service.
// All implementations must embed UnimplementedNetworkServiceServer
// for forward compatibility.
//
// Network management service
type NetworkServiceServer interface {
	CreateNetwork(context.Context, *CreateNetworkReq) (*CreateNetworkRes, error)
	ListNetworks(context.Context, *EmptyRequest) (*Networks, error)
	RemoveNetwork(context.Context, *RemoveNetworkReq) (*RemoveNetworkRes, error)
	mustEmbedUnimplementedNetworkServiceServer()
}

// UnimplementedNetworkServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNetworkServiceServer struct{}

func (UnimplementedNetworkServiceServer) CreateNetwork(context.Context, *CreateNetworkReq) (*CreateNetworkRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNetwork not implemented")
}
func (UnimplementedNetworkServiceServer) ListNetworks(context.Context, *EmptyRequest) (*Networks, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNetworks not implemented")
}
func (UnimplementedNetworkServiceServer) RemoveNetwork(context.Context, *RemoveNetworkReq) (*RemoveNetworkRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveNetwork not implemented")
}
func (UnimplementedNetworkServiceServer) mustEmbedUnimplementedNetworkServiceServer() {}
func (UnimplementedNetworkServiceServer) testEmbeddedByValue()                        {}

// UnsafeNetworkServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NetworkServiceServer will
// result in compilation errors.
type UnsafeNetworkServiceServer interface {
	mustEmbedUnimplementedNetworkServiceServer()
}

func RegisterNetworkServiceServer(s grpc.ServiceRegistrar, srv NetworkServiceServer) {
	// If the following call pancis, it indicates UnimplementedNetworkServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&NetworkService_ServiceDesc, srv)
}

func _NetworkService_CreateNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateNetworkReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServiceServer).CreateNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkService_CreateNetwork_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServiceServer).CreateNetwork(ctx, req.(*CreateNetworkReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkService_ListNetworks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServiceServer).ListNetworks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkService_ListNetworks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServiceServer).ListNetworks(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkService_RemoveNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveNetworkReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServiceServer).RemoveNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkService_RemoveNetwork_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServiceServer).RemoveNetwork(ctx, req.(*RemoveNetworkReq))
	}
	return interceptor(ctx, in, info, handler)
}

// NetworkService_ServiceDesc is the grpc.ServiceDesc for NetworkService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NetworkService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "joblet.NetworkService",
	HandlerType: (*NetworkServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateNetwork",
			Handler:    _NetworkService_CreateNetwork_Handler,
		},
		{
			MethodName: "ListNetworks",
			Handler:    _NetworkService_ListNetworks_Handler,
		},
		{
			MethodName: "RemoveNetwork",
			Handler:    _NetworkService_RemoveNetwork_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "joblet.proto",
}

const (
	VolumeService_CreateVolume_FullMethodName = "/joblet.VolumeService/CreateVolume"
	VolumeService_ListVolumes_FullMethodName  = "/joblet.VolumeService/ListVolumes"
	VolumeService_RemoveVolume_FullMethodName = "/joblet.VolumeService/RemoveVolume"
)

// VolumeServiceClient is the client API for VolumeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Volume management service
type VolumeServiceClient interface {
	CreateVolume(ctx context.Context, in *CreateVolumeReq, opts ...grpc.CallOption) (*CreateVolumeRes, error)
	ListVolumes(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*Volumes, error)
	RemoveVolume(ctx context.Context, in *RemoveVolumeReq, opts ...grpc.CallOption) (*RemoveVolumeRes, error)
}

type volumeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVolumeServiceClient(cc grpc.ClientConnInterface) VolumeServiceClient {
	return &volumeServiceClient{cc}
}

func (c *volumeServiceClient) CreateVolume(ctx context.Context, in *CreateVolumeReq, opts ...grpc.CallOption) (*CreateVolumeRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateVolumeRes)
	err := c.cc.Invoke(ctx, VolumeService_CreateVolume_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeServiceClient) ListVolumes(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*Volumes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Volumes)
	err := c.cc.Invoke(ctx, VolumeService_ListVolumes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeServiceClient) RemoveVolume(ctx context.Context, in *RemoveVolumeReq, opts ...grpc.CallOption) (*RemoveVolumeRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveVolumeRes)
	err := c.cc.Invoke(ctx, VolumeService_RemoveVolume_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VolumeServiceServer is the server API for VolumeService service.
// All implementations must embed UnimplementedVolumeServiceServer
// for forward compatibility.
//
// Volume management service
type VolumeServiceServer interface {
	CreateVolume(context.Context, *CreateVolumeReq) (*CreateVolumeRes, error)
	ListVolumes(context.Context, *EmptyRequest) (*Volumes, error)
	RemoveVolume(context.Context, *RemoveVolumeReq) (*RemoveVolumeRes, error)
	mustEmbedUnimplementedVolumeServiceServer()
}

// UnimplementedVolumeServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVolumeServiceServer struct{}

func (UnimplementedVolumeServiceServer) CreateVolume(context.Context, *CreateVolumeReq) (*CreateVolumeRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateVolume not implemented")
}
func (UnimplementedVolumeServiceServer) ListVolumes(context.Context, *EmptyRequest) (*Volumes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListVolumes not implemented")
}
func (UnimplementedVolumeServiceServer) RemoveVolume(context.Context, *RemoveVolumeReq) (*RemoveVolumeRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveVolume not implemented")
}
func (UnimplementedVolumeServiceServer) mustEmbedUnimplementedVolumeServiceServer() {}
func (UnimplementedVolumeServiceServer) testEmbeddedByValue()                       {}

// UnsafeVolumeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VolumeServiceServer will
// result in compilation errors.
type UnsafeVolumeServiceServer interface {
	mustEmbedUnimplementedVolumeServiceServer()
}

func RegisterVolumeServiceServer(s grpc.ServiceRegistrar, srv VolumeServiceServer) {
	// If the following call pancis, it indicates UnimplementedVolumeServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VolumeService_ServiceDesc, srv)
}

func _VolumeService_CreateVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVolumeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServiceServer).CreateVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VolumeService_CreateVolume_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServiceServer).CreateVolume(ctx, req.(*CreateVolumeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VolumeService_ListVolumes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServiceServer).ListVolumes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VolumeService_ListVolumes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServiceServer).ListVolumes(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VolumeService_RemoveVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveVolumeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServiceServer).RemoveVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VolumeService_RemoveVolume_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServiceServer).RemoveVolume(ctx, req.(*RemoveVolumeReq))
	}
	return interceptor(ctx, in, info, handler)
}

// VolumeService_ServiceDesc is the grpc.ServiceDesc for VolumeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VolumeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "joblet.VolumeService",
	HandlerType: (*VolumeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateVolume",
			Handler:    _VolumeService_CreateVolume_Handler,
		},
		{
			MethodName: "ListVolumes",
			Handler:    _VolumeService_ListVolumes_Handler,
		},
		{
			MethodName: "RemoveVolume",
			Handler:    _VolumeService_RemoveVolume_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "joblet.proto",
}

const (
	MonitoringService_GetSystemStatus_FullMethodName     = "/joblet.MonitoringService/GetSystemStatus"
	MonitoringService_StreamSystemMetrics_FullMethodName = "/joblet.MonitoringService/StreamSystemMetrics"
)

// MonitoringServiceClient is the client API for MonitoringService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// System monitoring service
type MonitoringServiceClient interface {
	GetSystemStatus(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*SystemStatusRes, error)
	StreamSystemMetrics(ctx context.Context, in *StreamMetricsReq, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SystemMetricsRes], error)
}

type monitoringServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMonitoringServiceClient(cc grpc.ClientConnInterface) MonitoringServiceClient {
	return &monitoringServiceClient{cc}
}

func (c *monitoringServiceClient) GetSystemStatus(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*SystemStatusRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SystemStatusRes)
	err := c.cc.Invoke(ctx, MonitoringService_GetSystemStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monitoringServiceClient) StreamSystemMetrics(ctx context.Context, in *StreamMetricsReq, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SystemMetricsRes], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MonitoringService_ServiceDesc.Streams[0], MonitoringService_StreamSystemMetrics_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamMetricsReq, SystemMetricsRes]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MonitoringService_StreamSystemMetricsClient = grpc.ServerStreamingClient[SystemMetricsRes]

// MonitoringServiceServer is the server API for MonitoringService service.
// All implementations must embed UnimplementedMonitoringServiceServer
// for forward compatibility.
//
// System monitoring service
type MonitoringServiceServer interface {
	GetSystemStatus(context.Context, *EmptyRequest) (*SystemStatusRes, error)
	StreamSystemMetrics(*StreamMetricsReq, grpc.ServerStreamingServer[SystemMetricsRes]) error
	mustEmbedUnimplementedMonitoringServiceServer()
}

// UnimplementedMonitoringServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMonitoringServiceServer struct{}

func (UnimplementedMonitoringServiceServer) GetSystemStatus(context.Context, *EmptyRequest) (*SystemStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSystemStatus not implemented")
}
func (UnimplementedMonitoringServiceServer) StreamSystemMetrics(*StreamMetricsReq, grpc.ServerStreamingServer[SystemMetricsRes]) error {
	return status.Errorf(codes.Unimplemented, "method StreamSystemMetrics not implemented")
}
func (UnimplementedMonitoringServiceServer) mustEmbedUnimplementedMonitoringServiceServer() {}
func (UnimplementedMonitoringServiceServer) testEmbeddedByValue()                           {}

// UnsafeMonitoringServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MonitoringServiceServer will
// result in compilation errors.
type UnsafeMonitoringServiceServer interface {
	mustEmbedUnimplementedMonitoringServiceServer()
}

func RegisterMonitoringServiceServer(s grpc.ServiceRegistrar, srv MonitoringServiceServer) {
	// If the following call pancis, it indicates UnimplementedMonitoringServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MonitoringService_ServiceDesc, srv)
}

func _MonitoringService_GetSystemStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonitoringServiceServer).GetSystemStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonitoringService_GetSystemStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonitoringServiceServer).GetSystemStatus(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonitoringService_StreamSystemMetrics_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamMetricsReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MonitoringServiceServer).StreamSystemMetrics(m, &grpc.GenericServerStream[StreamMetricsReq, SystemMetricsRes]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MonitoringService_StreamSystemMetricsServer = grpc.ServerStreamingServer[SystemMetricsRes]

// MonitoringService_ServiceDesc is the grpc.ServiceDesc for MonitoringService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MonitoringService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "joblet.MonitoringService",
	HandlerType: (*MonitoringServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSystemStatus",
			Handler:    _MonitoringService_GetSystemStatus_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamSystemMetrics",
			Handler:       _MonitoringService_StreamSystemMetrics_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "joblet.proto",
}
